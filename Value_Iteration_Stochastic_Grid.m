%% Дано
% States and actions
n = 10;
N = n^2;
[y,x] = meshgrid(1:n,1:n);
S = [x(:)';y(:)'];
A = [1,2,3,4];

% Costs
C = sparse(N,4);

% Transition matrices
T{1} = sparse(N,N);
T{2} = sparse(N,N);
T{3} = sparse(N,N);
T{4} = sparse(N,N);

%% Решение
% Определение препятствий
for i = 1:n
    for j = 1:n
        % Встреча с препятствием должна стоить 50 ед. (Препятствия
        % установлены в точках (5,6)  (5,7) (6,6) (6,7))
        if all([i,j] == [5,6]) || all([i,j] == [5,7]) || all([i,j] == [6,6]) || all([i,j] == [6,7])
            C((j-1)*n+i,:) = 50*ones(1,4);
        else
            % Если же клетка препятствием не является, то цена хода
            % равняется единице
            C((j-1)*n+i,:) = ones(1,4);
        end
    end
end
            
% Стоимость хода к цели, установленной в точке (3,3) должна равняться нулю
C(2*n+3,:) = zeros(1,4); 

% Вероятности перемещения
p_correct = 0.75;
p_wrong = (1 - p_correct)/3;

%% Действия
% Действие 1 - Движение вверх
for i = 1:N   
    if any(i == [(N-n+1):N]) % на верхней границе
        T{1}(i,i) = 1;
    elseif (mod(i,n) == 0) % на правой границе
        T{1}(i,i+n) = 1;
    elseif any(i == [1:n]) % на нижней границе
        T{1}(i,i+n) = 1;
    elseif (mod(i,n) == 1) % на левой границе
        T{1}(i,i+n) = 1;        
    else
    % в других случаях
    T{1}(i,i-n) = p_wrong;
    T{1}(i,i+1) = p_wrong;
    T{1}(i,i+n) = p_correct;
    T{1}(i,i-1) = p_wrong;
    end
end

% Действие 2 - Движение направо
for i = 1:N 
    if (mod(i,n) == 0) % на правой границе
        T{2}(i,i) = 1;
    elseif any(i == [(N-n+1):N]) % на верхней границе
        T{2}(i,i+1) = 1;
    elseif any(i == [1:n]) % на нижней границе
        T{2}(i,i+1) = 1;
    elseif (mod(i,n) == 1) % на левой границе
        T{2}(i,i+1) = 1;        
    else
    % в других случаях
    T{2}(i,i-n) = p_wrong;
    T{2}(i,i+1) = p_correct;
    T{2}(i,i+n) = p_wrong;
    T{2}(i,i-1) = p_wrong;
    end
end

% Действие 3 - Движение вниз
for i = 1:N 
    if any(i == [1:n]) % на нижней границе
        T{3}(i,i) = 1;
    elseif (mod(i,n) == 1) % на левой границе
        T{3}(i,i-n) = 1;  
    elseif any(i == [(N-n+1):N]) % на верхней границе
        T{3}(i,i-n) = 1;
    elseif (mod(i,n) == 0) % на правой границе
        T{3}(i,i-n) = 1;
    else
    % в других случаях
    T{3}(i,i-n) = p_correct;
    T{3}(i,i+1) = p_wrong;
    T{3}(i,i+n) = p_wrong;
    T{3}(i,i-1) = p_wrong;
    end
end

% Действие 4 - Движение налево
for i = 1:N 
    if (mod(i,n) == 1) % на левой границе
        T{4}(i,i) = 1;
    elseif any(i == [(N-n+1):N]) % на врехней границе
        T{4}(i,i-1) = 1;
    elseif (mod(i,n) == 0)% на правой границе
        T{4}(i,i-1) = 1;
    elseif any(i == [1:n]) % на нижней границе
        T{4}(i,i-1) = 1;            
    else
    % в других случаях
    T{4}(i,i-n) = p_wrong;
    T{4}(i,i+1) = p_wrong;
    T{4}(i,i+n) = p_wrong;
    T{4}(i,i-1) = p_correct;
    end
end

% Перестать двигаться при достижении цели
for i = 1:N
    T{1}(2*n+3,i) = 0;
    T{2}(2*n+3,i) = 0;
    T{3}(2*n+3,i) = 0;
    T{4}(2*n+3,i) = 0;
end
    
T{1}(2*n+3,2*n+3) = 1;
T{2}(2*n+3,2*n+3) = 1;
T{3}(2*n+3,2*n+3) = 1;
T{4}(2*n+3,2*n+3) = 1;